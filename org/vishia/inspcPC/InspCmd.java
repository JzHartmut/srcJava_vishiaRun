package org.vishia.inspcPC;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.Map;

import javax.script.ScriptException;

import org.vishia.cmd.JZcmdExecuter;
import org.vishia.cmd.JZcmdScript;
import org.vishia.communication.InterProcessCommFactorySocket;
import org.vishia.inspcPC.mng.InspcMng;
import org.vishia.mainCmd.MainCmd;
import org.vishia.mainCmd.MainCmdLogging_ifc;
import org.vishia.mainCmd.MainCmd_ifc;
import org.vishia.util.DataAccess;
import org.vishia.util.IndexMultiTable;
import org.vishia.util.ReplaceAlias_ifc;
import org.vishia.zcmd.JZcmd;

/**This class contains a main-routine to execute inspector commands in a command line.
 * The inspector command is read from a textual file.
 * @author Hartmut Schorrig
 *
 */
public class InspCmd
{


/** Aggregation to the Console implementation class.*/
final MainCmd_ifc console;




public static void main(String [] sArgs)
{ 
  try{ //for unexpected exceptions
    int exitlevel = smain(sArgs);
    System.exit(exitlevel);
  } catch(Exception exc) {
    //catch the last level of error. No error is reported direct on command line!
    System.err.println("InspCmd - script exception; " + exc.getMessage());
    exc.printStackTrace(System.err);
    System.exit(MainCmdLogging_ifc.exitWithErrors);
  }
}



/**Invocation from another java program without exit the JVM
 * @param sArgs same like {@link #main(String[])}
 * @return the exit level 0 - successful 1..6 see {@link MainCmdLogging_ifc#exitWithArgumentError} etc.
 * @throws IllegalAccessException 
 */
public static int smain(String[] sArgs) throws ScriptException, IllegalAccessException 
{
  String sRet = null;
  Args args = new Args();
  CmdLine mainCmdLine = new CmdLine(args, sArgs); //the instance to parse arguments and others.
  mainCmdLine.setReportLevel(0);  //over-write if argument given. Don't use a report.txt by default.
  try{ mainCmdLine.parseArguments(); }
  catch(Exception exception)
  { sRet = "InspcCmd - Argument error ;" + exception.getMessage();
  mainCmdLine.report(sRet, exception);
  mainCmdLine.setExitErrorLevel(MainCmdLogging_ifc.exitWithArgumentError);
  }
  if(args.sFileScript ==null){
    mainCmdLine.writeHelpInfo(null);
  } else {
    if(sRet == null) {
      InspCmd main = new InspCmd(mainCmdLine);
      Writer out = null;
      File fOut = args.sFileTextOut == null ? null : new File(args.sFileTextOut);
      try {
        out = args.sFileTextOut == null ? null : new FileWriter(fOut);
        main.execute(args, out);
      } catch (IOException e) {
        throw new ScriptException(e);
      }
      if (out !=null) {
        try{ out.close(); }
        catch(IOException exc){ throw new RuntimeException(exc); }
      }
     
      main.console.writeInfoln("SUCCESS");

    }
  }
  return mainCmdLine.getExitErrorLevel();
}




private static class Args
{

/**path to the script file for the generation or execution script of JZcmd.*/
String sFileScript;

/**path to the text output file which is generated by JZcmd. May be null, then no text output. */
String sFileTextOut;

String sScriptCheck;

File fileTestXml;

}




  /**The organization class for command line invocation.
   */
  private static class CmdLine extends MainCmd
  {
  
  public final Args argData;
  
  protected final MainCmd.Argument[] argList =
  { new MainCmd.Argument("", ":pathTo/input.script"
      , new MainCmd.SetArgument(){ @Override public boolean setArgument(String val){ 
        argData.sFileScript = val; return true;
      }})
  , new MainCmd.Argument("-t", ":OUTEXT pathTo text-File for output"
      , new MainCmd.SetArgument(){ @Override public boolean setArgument(String val){ 
        argData.sFileTextOut = val; return true;
      }})
  };
  
  
  protected CmdLine(Args argData, String[] sCmdlineArgs){
    super(sCmdlineArgs);
    this.argData = argData;
    super.addAboutInfo("Execution of Inspspector-Commands from a file");
    super.addAboutInfo("made by HSchorrig, Version 1.0, 2016-01-06");
    super.addHelpInfo("args SCRIPTFILE [-t:OUTEXT]");
    super.addArgument(argList);
    super.addHelpInfo("==Standard arguments of MainCmd==");
    super.addStandardHelpInfo();
  }
  
  @Override protected void callWithoutArguments()
  { //overwrite with empty method - it is admissible.
  }
  
  
  @Override protected boolean checkArguments()
  {
    if(argData.sFileScript ==null) return false;
    else return true;
  } 
  
  
  }
  

  
  
  
ReplaceAlias_ifc replAlias = new ReplaceAlias_ifc(){

  Map<String, String> repl;
  
  @Override public void addDataReplace(Map<String, String> src)
  { repl = src;
  }

  @Override public void addDataReplace(String alias, String value)
  {
    // TODO Auto-generated method stub
    
  }

  @Override public String replaceDataPathPrefix(String path)
  {
    if(repl == null) return path;
    int sep = path.indexOf(':');
    if(sep >0) {
      String st = repl.get(path.substring(0, sep));
      if(st !=null) { 
        return st + path.substring(sep);
      } else {
        return path;  //no replacement done.
      }
    }
    else return path;
  }
  
};  


public InspCmd(MainCmd_ifc console)
{
  super();
  this.console = console;
}



void execute(Args args, Writer out) throws IOException, ScriptException, IllegalAccessException
{

  //String sRet = null;
  //File fScriptCheck = args.sScriptCheck == null ? null : new File(args.sScriptCheck);
  
  JZcmdScript script = JZcmd.translateAndSetGenCtrl(new File(args.sFileScript), console);
  
  
  JZcmdExecuter executer = new JZcmdExecuter(console);
  executer.initialize(null, false, null, null);
  //create variables as argument for exexSub:
  Map<String, DataAccess.Variable<Object>> vars = new IndexMultiTable<String, DataAccess.Variable<Object>>(IndexMultiTable.providerString);
  //define String ownIp
  DataAccess.createOrReplaceVariable(vars, "ownIp", 'S', null, false);
  //define Map targets
  Map<String, DataAccess.Variable<Object>> idx1TargetIpcAddr = new IndexMultiTable<String, DataAccess.Variable<Object>>(IndexMultiTable.providerString);
  DataAccess.createOrReplaceVariable(vars, "targets", 'M', idx1TargetIpcAddr, false);
  //
  //invoke the sub routine args
  //
  vars = executer.execSub(script, "args", vars, false, out, null);
  String sOwnIpcAddr = vars.get("ownIp").value().toString();
  Map<String, String> idxTargetIpcAddr = new IndexMultiTable<String, String>(IndexMultiTable.providerString);
  for(Map.Entry <String, DataAccess.Variable<Object>> entry: idx1TargetIpcAddr.entrySet()){
    idxTargetIpcAddr.put(entry.getKey(), entry.getValue().value().toString());
  }
  //replAlias.addDataReplace(idxTargetIpcAddr);
  new InterProcessCommFactorySocket();
  InspcMng inspcMng = new InspcMng(sOwnIpcAddr, idxTargetIpcAddr, false, null);
  inspcMng.complete_ReplaceAlias_ifc(replAlias);
  inspcMng.startupThreads();
  //create devices:
  
  try{
    executer.setScriptVariable("inspc", 'O', inspcMng, true);
  } catch(IllegalAccessException exc) {
    //TODO
  }
  executer.executeScriptLevel(script, null);
  executer.execute(script, false, true, out, null);
  //JZcmd.execute(executer, fileScript, out, console.currdir(), true, fScriptCheck, console);


}






}
